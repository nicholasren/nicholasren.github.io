<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <title>nicholasren.github.io by nicholasren</title>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26893631-1']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();

     </script>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>nicholasren.github.io</h1>
        <h2>ruby, scala </h2>
      </div>
    </header>

    <div class="container">
    <div class="content">
  <div class="row">
    <div class="span16">
      <div class="page-header">
        <h1>KNN算法ruby实现</h1>
      </div>
      <h3>背景</h3>

<p>KNN，全称K-nearest-neighbour，是机器学习中最简单的一个分类算法，它的原理是通过对样本数据的学习，对于给定的新的数据，找出与其距离最近的K个样本数据，根据这K个最近样本数据的类别，来确定这个给定数据的类别。</p>

<p>Coolshell上有<a href="http://coolshell.cn/articles/8052.html">对这个算法的讲解</a>，我的同事邱俊涛也写了一篇关于KNN算法python实现的<a href="http://icodeit.org/2013/01/k-nearest-neighbour/">文章</a>。本文讲解一个KNN算法的ruby实现。</p>

<h3>输入</h3>

<p>程序输入格式如下：</p>

<pre><code>x0,x1,x2,…xn|v0
y0,y1,y2,…yn|v1
z0,z1,z2,…zn|v2
</code></pre>

<p>每行为一个数据样本，以第一行为例，x0,x1...xn为一个向量，v0为该数据的类别。</p>

<h3>学习</h3>

<p>从给定文件加载样本数据:</p>

<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">train</span> <span class="n">file_path</span>
  <span class="vi">@samples</span> <span class="o">=</span> <span class="n">from_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>


<p>@sample的格式如下：</p>

<pre><code>[
    {:vector =&gt; [x0, x1, x2, …xn], :value =&gt; v0},
    {:vector =&gt; [y0, y1, y2, …yn], :value =&gt; v1},
    …
    {:vector =&gt; [z0, z1, z2, …zn], :value =&gt; vn},
]
</code></pre>

<h3>分类</h3>

<p>对于给定的数据，要判断其属于样本数据中的哪一类，需解决如下几个问题：</p>

<ol>
<li>计算给定数据和样本数据之间的距离</li>
<li>找出与给定数据距离最小的K个样本数据</li>
<li>从这K个样本数据中找出样本多的那个分类，即为给定数据的分类。</li>
</ol>


<h5>1. 计算距离</h5>

<p>给定两个向量<code>[x0, x1,…xn]</code>，<code>[y0, y1,...yn]</code>计算两个向量之间的距离如下：</p>

<pre><code>(x0 - y0)^2 + (x1 - y1)^2 + … + (xn - yn)^2
</code></pre>

<p>因此，对于给定的两个向量a，b，其距离计算逻辑如下：</p>

<div class="highlight"><pre><code class="ruby"><span class="c1">#a and b are two vectors</span>
<span class="k">def</span> <span class="nf">distance_between</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
  <span class="n">a</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">x</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">}</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">){</span><span class="o">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">x</span><span class="o">|</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">}</span>
<span class="k">end</span>
</code></pre></div>


<h5>2. 找出与给定数据距离最小的K个样本数据</h5>

<p>可以采用计算给定数据与所有样本数据的距离，然后采用<a href="http://en.wikipedia.org/wiki/Binary_heap">最大堆</a>来找出<strong>top k</strong>个样本数据。</p>

<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">nearest_neighbours</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">k</span>
  <span class="n">heap</span> <span class="o">=</span> <span class="no">MaxHeap</span><span class="o">.</span><span class="n">new</span>
  <span class="vi">@samples</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sample</span><span class="o">|</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_between</span><span class="p">(</span><span class="n">sample</span><span class="o">[</span><span class="ss">:vector</span><span class="o">]</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">heap</span><span class="o">.</span><span class="n">insert</span> <span class="no">Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">heap</span><span class="o">.</span><span class="n">take_top</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">compact</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:sample</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>


<h5>3. 从这K个样本数据中找出样本多的那个分类，即为给定数据的分类。</h5>

<p>对得到的样本根据其类别进行分组，组内元素多的那个类别，即为该给定数据的分类</p>

<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">value_with_max_vote</span> <span class="n">xs</span>
  <span class="n">value_with_votes</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">group_by</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">[</span><span class="ss">:value</span><span class="o">]</span><span class="p">}</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">value</span><span class="p">,</span> <span class="n">group</span><span class="o">|</span> <span class="p">{</span><span class="ss">:value</span> <span class="o">=&gt;</span> <span class="n">value</span><span class="p">,</span> <span class="ss">:votes</span> <span class="o">=&gt;</span> <span class="n">group</span><span class="o">.</span><span class="n">length</span><span class="p">}}</span>
  <span class="n">value_with_votes</span><span class="o">.</span><span class="n">max_by</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">[</span><span class="ss">:votes</span><span class="o">]</span> <span class="p">}</span><span class="o">[</span><span class="ss">:value</span><span class="o">]</span>
<span class="k">end</span>
</code></pre></div>


<p>综合上面的几个小任务，我们得到KNN分类算法的实现：</p>

<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">categorize</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">k</span>
  <span class="n">neighbours</span> <span class="o">=</span> <span class="n">nearest_neighbours_for</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">k</span>
  <span class="n">value_with_max_vote</span> <span class="n">neighbours</span>
<span class="k">end</span>
</code></pre></div>


<p>代码的完整版本可以在<a href="https://github.com/nicholasren/knn">这里</a>找到。</p>

    </div>
  </div>
</div>

<div id="disqus_thread" style="width:100%">
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'nicholasrensblog'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>

  </body>
</html>
