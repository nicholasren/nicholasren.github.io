<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <title>nicholasren.github.io by nicholasren</title>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26893631-1']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();

     </script>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>nicholasren.github.io</h1>
        <h2>ruby, scala </h2>
      </div>
    </header>

    <div class="container">
    <div class="content">
  <div class="row">
    <div class="span16">
      <div class="page-header">
        <h1>Water pouring problem的scala实现</h1>
      </div>
      <p><strong>Note:</strong>  本文中的程序来自Martin Ordersky在www.coursea.org上所开设课程中的样例代码，文章主要目的是讲述我对此类问题解法及scala lazy evluation的理解。</p>

<h3>问题描述</h3>

<p>给你一个容量为9升的杯子和一个容量为4升的杯子，水不限使用，要求精确得到6升水。这就是“倒水问题”。我这里会讲述一个试用scala穷举法实现的一个例子。</p>

<h3>建模</h3>

<p>首先我们对这个问题进行建模。这个问题可以泛化为如下形式：</p>

<pre><code>两个容量固定的杯子，可选的动作有：  
    + 加满
    + 倒空
    + 从一个杯子倒入另一个杯子

初始状态为两个杯子都空，结束状态为其中一个杯子中的水量为所期望的结果。
</code></pre>

<p>从上面的描述中我们可以得到如下几个概念<strong>状态</strong>，<strong>动作</strong>，<strong>路径</strong>。</p>

<p><strong>状态</strong>用于表述各个杯子中当前的水量，<strong>动作</strong>用来改变各个杯子中水量，<strong>路径</strong>用于表示到达某一状态的动作序列。</p>

<h4>状态</h4>

<p>我们可以用一个<code>Vector[Int]</code>来表述杯子的状态，下标为杯子编号，元素值为当前杯子中的水量，另外，我们还需要一个<code>Vector[Int]</code>表示杯子的容量，下标为杯子编号，元素值为杯子的容量。于是我们得到如下代码：</p>

<div class="highlight"><pre><code class="scala">    <span class="k">class</span> <span class="nc">Pouring</span><span class="o">(</span><span class="n">capacity</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="o">{</span>
        <span class="c1">//States</span>
        <span class="k">val</span> <span class="n">initialState</span> <span class="k">=</span> <span class="n">capacity</span> <span class="n">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">}</span>    
</code></pre></div>


<p><code>capacity</code>为杯子容量， <code>intialState</code>为问题初始状态。</p>

<h4>动作</h4>

<p>由上可知，解决这个问题可以有三种动作, <code>Empty</code>, <code>Fill</code>, <code>Pour</code>，每个动作都会导致状态发生变化，于是我们得到如下代码：</p>

<div class="highlight"><pre><code class="scala">    <span class="c1">//Moves</span>
    <span class="k">trait</span> <span class="nc">Move</span> <span class="o">{</span> 
        <span class="k">def</span> <span class="n">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> 
    <span class="o">}</span>
    
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Empty</span><span class="o">(</span><span class="n">glass</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Move</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">state</span> <span class="n">updated</span> <span class="o">(</span><span class="n">glass</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">}</span>
    
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Fill</span><span class="o">(</span><span class="n">glass</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Move</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">state</span> <span class="n">updated</span> <span class="o">(</span><span class="n">glass</span><span class="o">,</span> <span class="n">capacity</span><span class="o">(</span><span class="n">glass</span><span class="o">))</span>
    <span class="o">}</span>
    
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Pour</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Move</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">state</span><span class="o">(</span><span class="n">from</span><span class="o">)</span> <span class="n">min</span> <span class="o">(</span><span class="n">capacity</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">-</span> <span class="n">state</span><span class="o">(</span><span class="n">to</span><span class="o">))</span>
          <span class="n">state</span> <span class="n">updated</span> <span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">state</span><span class="o">(</span><span class="n">from</span><span class="o">)</span> <span class="o">-</span> <span class="n">amount</span><span class="o">)</span> <span class="n">updated</span> <span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="n">state</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">+</span> <span class="n">amount</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div>


<p>注意因为要考虑杯子的容量和杯子中剩余的水量，<code>Pour</code>中的<code>change</code>方法稍微复杂了些。</p>

<h4>路径</h4>

<p>接下来到了最重要的路径部分了，路径是到达某一状态的动作序列，我们需要一个<code>List[Move]</code>表述动作序列，一个<code>Vector[Int]</code>表述结束状态。
还需要一个<code>extend</code>方法来扩展当前的动作序列，即在当前路径上，应用一个动作（Fill, Empty, Pour），得到一个新的路径。于是我们得到如下代码：</p>

<div class="highlight"><pre><code class="scala">    <span class="c1">//Paths</span>
    <span class="k">class</span> <span class="nc">Path</span><span class="o">(</span><span class="n">history</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Move</span><span class="o">],</span> <span class="k">val</span> <span class="n">endState</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">extend</span><span class="o">(</span><span class="n">move</span><span class="k">:</span> <span class="kt">Move</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Path</span><span class="o">(</span><span class="n">move</span> <span class="o">::</span> <span class="n">history</span><span class="o">,</span> <span class="n">move</span> <span class="n">change</span> <span class="n">endState</span><span class="o">)</span>
        <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="o">(</span><span class="n">history</span><span class="o">.</span><span class="n">reverse</span> <span class="n">mkString</span> <span class="s">&quot; &quot;</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot; --&gt;&quot;</span> <span class="o">+</span> <span class="n">endState</span>
    <span class="o">}</span>
</code></pre></div>


<h3>算法</h3>

<p>这里我们要采用的是<strong>穷举法：</strong></p>

<p>穷举从初始状态出发所有可能的动作，以及可能达到的状态，再穷举从这些状态出发所有可能的动作以及可能达到的状态，如此反复，直到找到一个可能达到的状态满足期望，则到达这个状态所经历的所有动作组成的路径即为问题的解。</p>

<p>首先我们来穷举给定一组杯子可能的动作：</p>

<div class="highlight"><pre><code class="scala">    <span class="k">val</span> <span class="n">glasses</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">capacity</span><span class="o">.</span><span class="n">length</span>
    <span class="k">val</span> <span class="n">moves</span> <span class="k">=</span>
        <span class="o">(</span><span class="k">for</span> <span class="o">(</span><span class="n">g</span> <span class="k">&lt;-</span> <span class="n">glasses</span><span class="o">)</span> <span class="k">yield</span> <span class="nc">Empty</span><span class="o">(</span><span class="n">g</span><span class="o">))</span> <span class="o">++</span>
        <span class="o">(</span><span class="k">for</span> <span class="o">(</span><span class="n">g</span> <span class="k">&lt;-</span> <span class="n">glasses</span><span class="o">)</span> <span class="k">yield</span> <span class="nc">Fill</span><span class="o">(</span><span class="n">g</span><span class="o">))</span> <span class="o">++</span>
        <span class="o">(</span><span class="k">for</span> <span class="o">(</span><span class="n">from</span> <span class="k">&lt;-</span> <span class="n">glasses</span><span class="o">;</span> <span class="n">to</span> <span class="k">&lt;-</span> <span class="n">glasses</span> <span class="k">if</span> <span class="n">from</span> <span class="o">!=</span> <span class="n">to</span><span class="o">)</span> <span class="k">yield</span> <span class="nc">Pour</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">))</span>  
</code></pre></div>


<p>其次，在不进行任何动作时，动作列表为空，所达到的状态为初始状态，则：</p>

<div class="highlight"><pre><code class="scala">    <span class="k">val</span> <span class="n">initialPath</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Path</span><span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="n">initialState</span><span class="o">)</span>
</code></pre></div>


<p>接下来到最关键的部分了，<strong>穷举从初始状态出发的所有可能扩展出来的路径及其所达到的状态</strong>，由于从任何状态开始穷举，都会得到一个一组路径，而不是一个，于是我们首先定义一个从给定一组路径，穷举其可能扩展出来的的路径的方法：</p>

<div class="highlight"><pre><code class="scala">     <span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">paths</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Path</span><span class="o">],</span> <span class="n">explored</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Path</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">paths</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">empty</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">more</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
                <span class="n">path</span> <span class="k">&lt;-</span> <span class="n">paths</span>
                <span class="n">next</span> <span class="k">&lt;-</span> <span class="n">moves</span> <span class="n">map</span> <span class="n">path</span><span class="o">.</span><span class="n">extend</span>
                <span class="k">if</span> <span class="o">!(</span><span class="n">explored</span> <span class="n">contains</span> <span class="n">next</span><span class="o">.</span><span class="n">endState</span><span class="o">)</span>
            <span class="o">}</span> <span class="k">yield</span> <span class="n">next</span>
            <span class="n">paths</span> <span class="o">#::</span> <span class="n">from</span><span class="o">(</span><span class="n">more</span><span class="o">,</span> <span class="n">explored</span> <span class="o">++</span> <span class="o">(</span><span class="n">more</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">endState</span><span class="o">)))</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div>


<p><code>paths</code>为此次穷举的初始路径集合, <code>explored</code>用于记录已经穷举过的状态，以避免找出多条达到相同状态的路径，此方法通过穷举初始路径集合，在各个路径上扩展所有的动作，去掉那些达到状态已经被穷举过的路径，得到一组新的路径。</p>

<p>那么，从初始路径出发，其可能扩展出来的路径极其可能达到的状态如下：</p>

<div class="highlight"><pre><code class="scala">    <span class="k">val</span> <span class="n">pathSets</span> <span class="k">=</span> <span class="n">from</span><span class="o">(</span><span class="nc">Set</span><span class="o">(</span><span class="n">initialPath</span><span class="o">),</span> <span class="nc">Set</span><span class="o">(</span><span class="n">initialState</span><span class="o">))</span>
</code></pre></div>


<p>对于给定的目标水量，遍历上述穷举结果路径找出<code>endState</code>包含目标水量的路径，如下：</p>

<div class="highlight"><pre><code class="scala">    
    <span class="k">def</span> <span class="n">solutions</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Path</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">{</span>
            <span class="n">pathSet</span> <span class="k">&lt;-</span> <span class="n">pathSets</span>
            <span class="n">path</span> <span class="k">&lt;-</span> <span class="n">pathSet</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endState</span> <span class="n">contains</span> <span class="n">target</span>
        <span class="o">}</span> <span class="k">yield</span> <span class="n">path</span>
    <span class="o">}</span>
</code></pre></div>


<h3>总结</h3>

<p>我们知道，穷举是一个无穷无尽的过程，上面的程序是如何运行的呢？其实是scala中强大的<a href="" title="http://en.wikipedia.org/wiki/Scala_(programming_language)#Lazy_.28non-strict.29_evaluation">lazy load</a>发挥了作用。我们再来看<code>from</code>方法的返回值类型，是<code>Stream[Set[Path]]</code>, <code>Stream</code> 用于表述元素序列，它的一个重要特点是，只有需要使用到其中的某个元素时，程序才会去计算这个元素。于是，在程序运行时，scala并不会一下子把所有可能的路径都计算出来。对于<code>solutions</code>方法，也是一样。因此，scala只有在从<code>solutions</code>的计算结果中获取满足条件的路径时，pathSet才会穷举可能的路径，并且在找到满足条件的路径后，计算会立即结束，不会再列举其余的可能。</p>

    </div>
  </div>
</div>

<div id="disqus_thread" style="width:100%">
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'nicholasrensblog'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>

  </body>
</html>
