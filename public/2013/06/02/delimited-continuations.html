<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <title>nicholasren.github.io by nicholasren</title>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26893631-1']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();

     </script>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>nicholasren.github.io</h1>
        <h2>ruby, scala </h2>
      </div>
    </header>

    <div class="container">
    <div class="content">
  <div class="row">
    <div class="span16">
      <div class="page-header">
        <h1>Delimited Continuations(WIP)</h1>
      </div>
      <p>本文译自<a href="http://jim-mcbeath.blogspot.in/2010/08/delimited-continuations.html">这里。</a></p>

<p>注：翻译尚未完成，标记为WIP的章节还未开始。</p>

<h4>Delimited Continuations</h4>

<p>Scala 2.8中引入的Delimited Continuation，可以被用来实现一些有趣的流程控制结构。</p>

<p>这是一篇很长很长的博客，我花了很长时间才理解了scala的<code>reset</code>和<code>shift</code>操作符，为了不让别人再掉进我遇到的坑里，我会从最基本概念开始介绍，如果你需要一个更短的介绍，请到文章的最后的“资源”部分查看其他的博客。</p>

<h4>目录</h4>

<ul>
<li>技术实现</li>
<li>Continuation Passing Style</li>
<li>嵌套CPS</li>
<li>全部CPS和有界限的Continuations</li>
<li>如何使用</li>
<li>CPS with Return</li>
<li>Reset和Shift</li>
<li>注解(WIP)</li>
<li>嵌套shift(WIP)</li>
<li>控制结构的限制(WIP)</li>
<li>建议(WIP)</li>
<li>资源(WIP)</li>
</ul>


<h4>技术实现</h4>

<p>为了使用scala的<em>delimited continuations</em>，你的scala版本必须高于2.8版本（译者注：目前的scala的最新版本是2.10.2），并且你还需要使用scala的continuation编译器插件。你可以通过在命令行制定一个参数来在编译时(compiling)和运行时(runtime)启用此插件：</p>

<pre><code>scalac -P:continuations:enable ${sourcefiles}
scala -P:continuations:enable ${classname}
</code></pre>

<p>在代码中，你还需要引入scala中对continuation的支持。</p>

<pre><code>import scala.util.continuations._
</code></pre>

<p>如何你忘记了引入上述包，你可能会得到类似下面的错误信息：</p>

<pre><code>&lt;console&gt;:6 error:not found value reset
        reset{      
        ^
</code></pre>

<h4>Continuation Passing Style</h4>

<p>为了理解scala的delimited continuations，首先你需要理解“continuation passing style”这个术语。</p>

<p>来看一下下面这段包含了方法调用的代码：</p>

<pre><code>def main{
    pre
    sub()
    post
}

def sub(){
    substuff
}
</code></pre>

<p><code>pre</code>和<code>post</code>表示在main方法中在调用sub方法之前、之后的代码，<code>substuff</code>表示sub方法中的所有代码。</p>

<p>当<code>sub</code>方法被调用时，系统会调度处理器执行sub中的代码，等sub中的代码执行完毕后，再继续执行main方法中其余代码。</p>

<p>我们可以把上面的代码进行些许重构，所有<code>pre</code>部分的代码可以被抽取到一个方法中，所有<code>post</code>部分的代码可以被抽取到另外一个方法中。甚至我们可以把每部分所需要的输入抽取为方法的参数，把每部分的的输出返回出来。经过以上修改，我们得到如下的代码：</p>

<pre><code>def main(m: M): Z = {
    val x: X = pre(m)
    val y: Y = sub(m, x)
    val z: Z = post(m, x, y)
    return z
}

def sub(m: M, x: X): Y {
    val y: Y = substuff(m, x)
    return y
}
</code></pre>

<p>现在，让我们做点改进，我们不让系统在执行<code>sub</code>完毕后执行自动执行post，而是显式地把要执行的代码作为<code>sub</code>额外的一个参数传递给<code>sub</code>。然后我们修改<code>sub</code>，在完成原有的计算逻辑，计算出要返回给<code>main</code>的值<code>y</code>以后，调用这个额外的参数，计算出它的返回值<code>z</code>，然后把这个<code>z</code>返回给<code>main</code>。</p>

<pre><code>def main(m: M) {
    val x: X = pre(m)
    val z: Z = sub(m, x, {post(m, x, _)})
    return z
}

def sub(m: M, x: X, subCont: Y =&gt; Z) {
    val y: Y = substuff(m, x)
    val z: Z = subCont(y)
    return z
}
</code></pre>

<p>当把包含<code>post</code>代码段传递给<code>sub</code>时，Scala生成一个记录了包含<code>post</code>执行上下文（当时的m，x值）的闭包，当这个闭包将来被执行时，可以获得的当时的执行上下文。</p>

<p>我们注意到，<code>main</code>方法中已无法看到<code>sub</code>方法原来的返回值<code>y</code>了，因此我们没法把<code>y</code>传递给<code>post</code>，我们用了一个占位符<code>_</code>来表示，这个值会在<code>sub</code>内部传递给<code>post</code>。我们可以把这个方法调用重写成一个更加明确的形式：</p>

<pre><code>val z: Z = sub(m, x, {y: Y =&gt; post(m, x, y)})
</code></pre>

<p>CPS的要点是“不要用<code>return</code>”。不像<code>direct style</code>那样调用一个子函数，待子函数执行完毕后返回给主函数，我们传递一个子函数执行结束后要被执行的continuation给子函数。</p>

<h4>嵌套CPS</h4>

<p>在上面的例子里，我们已经迈出了变换成CPS的第一步。为了能够使用CPS的一些更高级的特性，我们需要继续完成上面的变换。</p>

<p>在方法调用的最顶层，<code>main</code>方法仍然有返回值，但是，在CPS中没有<code>return</code>，我们如何处理这种情况？答案是，最高层的方法不能有返回值，我们来再来增加一个顶级的wrapper：</p>

<pre><code>def prog(m: M) {
    val z: Z = main(m)
    println(z)
    System.exit(z.exitValue)        
}
</code></pre>

<p>现在，我们可以对<code>prog</code>和<code>main</code>做同样的CPS变换：</p>

<pre><code>def prog(m: M) {
    main(m, {z: Z =&gt; {
        println(z)
        System.exit(z.exitValue)
    }})
}

def main(m: M, mainCont: Z =&gt; Unit): Unit = {
    val x: X = pre(m)
    val z: Z = sub(m, x, post(m, x, _))
    mainCont(z)
}
</code></pre>

<p>我们仍然在<code>sub</code>中使用了<code>return</code>，并且在<code>main</code>中使用<code>sub</code>的返回值。为了解决这个问题，我们需要把<code>mainCont</code>做为一个<code>continuation</code>传递给<code>sub</code>，修改后的<code>main</code>和<code>sub</code>如下：</p>

<pre><code>def main(m: M, mainCont: Z =&gt; Unit): Unit = {
    val x: X = pre(m)
    sub(m, x, y: Y =&gt; {
        val z: Z = post(m, x, y)
        mainCont(z)
    })
}

def sub(m:M,x:X, subCont: (Y) =&gt; Unit) {
    val y:Y = substuff(m,x)
    subCont(y)
}
</code></pre>

<p>我们已经有了个自顶向下的continuation（包含了System.exit），因此，当我们执行在<code>sub</code>中执行<code>subCont</code>时，它会先执行<code>post</code>，再执行<code>main</code>后面的代码，即<code>println</code>和<code>System.exit</code>。</p>

<p>如果我们想把<code>stubstuff</code>也转换成CPS，我们需要利用同样的转换机制转换<code>sub</code>和<code>substuff</code>。把<code>sub</code>中<code>substuff</code>之后所有的代码做为一个额外的参数传递给<code>substuff</code>，其中包含了从<code>main</code>传递到<code>sub</code>的continuation，也包含了从<code>prog</code>传递到<code>main</code>的continuation。</p>

<p>我们可以看到，每个continuation都会包含它之前所有的caller的continuation，换句话说，每个continuation都包含了这个方法调用结束后需要被执行的所有代码。另外一个很重要的一点是，在每个调用CPS的子方法的地方，这CPS方法调用总是这个方法的最后一行。</p>

<h4>Full versus Delimited Continuations</h4>

<p>在上面的讨论中，我们假设整个程序都被转换成CPS，这就是传统的CPS，我们也称之为Full Continutaitons。然而， 在原生不支持CPS的编程语言（例如scala）中使用CPS可能会使代码变得比较混乱， 因此如果能够把CPS的使用限定在特定的范围内是最好不过了。</p>

<p>这就是delimited continuation被发明出来的原因。仅仅留存部分后续要执行的程序，而不是尝试保存整个后续执行的程序。</p>

<p>我们再来看下上面的例子程序，那个<code>prog</code>方法与其他方法唯一的不同就是我们不能返回一个<code>Direct Style value</code>。如果我们移除掉那个<code>System.exit</code> ，我们可以在一个普通的<code>Direct Style</code>代码中调用<code>prog</code>，同时在<code>prog</code>和其子方法中使用CPS，每个方法以传递一个continuation给下一个方法结尾，直到最后一个continuaion被执行，CPS代码结束，控制返回到调用者<code>prog</code>中。</p>

<pre><code>def prog(m: M) {
    main(m, {z: Z =&gt; 
        println(z)
    })
}
</code></pre>

<h4>Use</h4>

<p>我们已经通过很大努力把我们的代码重写成CPS并且保持功能不变。现在我们再来看看如何修改代码只能使用CPS。</p>

<p>CPS的核心能力是：它能够提供一个显式的对象（continuation）来表示后续要执行的代码（或者，在Delimited continuation的情况下，后续要执行的部分代码）。在上面的例子中，我们在<code>sub</code>方的最后执行那个continuation。但是，如果我们不执行这个continuation，而是把它保存起来，例如一个singleton，会发生什么有意思的事情呢？</p>

<pre><code>object ContinuationSaver{
    var savedContinuation: Option[() =&gt; Unit] = None
    def save(saveCont: =&gt; Unit) = {savedContinuation = Some(saveCont _)}
}

def sub(m: M, x: X, subCont: Y =&gt; Unit) {
    val y: Y = substuff(m, x)
    ContinuationSaver.save {subCont(y)}
}
</code></pre>

<p><code>sub</code>保存了continuation后，<code>sub</code>就执行完毕，实际上整个delimited continuation已经执行完毕；控制已经返回到调用者<code>prog</code>中。但是在<code>ContinuationSaver</code>中我们仍然保存着那个记录着后续代码的continuation。实际上，我们已经把这些后续代码放到了挂起状态，并且在以后的任意时间重新执行。</p>

<p>我们不仅可以在将来执行这段代码，并且可以多次执行。我们甚至可以实现一个更加复杂的<code>ContinuationSaver</code>，能够保存多个<code>continuation</code>，并且记录哪个<code>continuation</code>应该被被执行，以什么样的顺序，执行多少次等。我们甚至可以把这些<code>continuation</code>持久化起来，或者发送到其他计算机上，如<a href="http://www.scala-lang.org/node/3485">Swarm</a>.</p>

<h4>CPS with Return</h4>

<p>在纯粹的CPS中是没有return的，但是Scala中有return，甚至在使用CPS的时候。在上一章节中我用了“控制回到了调用者<code>prog</code>”这样的术语。这跟普通的方法调用一样 —— 所有的中间方法都返回到自己的调用者，直到方法调用栈pop到第一个CPS方法调用。我假设所有的CPS方法都不返回值（即返回<code>Unit</code>），但是没有任何规则规定我们不能从CPS方法中返回值。</p>

<p>If we add a return value to the transformed code, this is not something we can get as a result of using the above transformation technique.</p>

<p>上面的例子展示了从一个<code>Direct Style</code>代码到CPS代码的转换过程，上述的转换方式总会生产一个返回值为<code>Unit</code>的代码。如果我们给上面转换后的代码加入返回值，通过上述的转换方式是做不到的。</p>

<p>如果给我们的CPS代码加入返回值，会发生什么样的事情呢？在上面的例子里， 子方法的最后一步总是在执行continuaiton，如果我们把这做为默认行为，当我们给CPS代码增加返回值时，这个返回值会沿着CPS方法调用链一直返回到最顶端的CPS方法，在Direct Style代码中表现为最顶端的CPS方法的返回值。当然，任何一个中间的CPS方法都有可能修改或者替换这个返回值。</p>

<p>举个例子，我们让最新版本的<code>sub</code>方法（把continuation保存在ContinuationSaver中的那个）返回一个Int值。</p>

<pre><code>object ContinuationSaver {
    var numberOfSavedContinuations = 0
    var savedContinuation: Option[() =&gt; Unit] = None
    def save(saveCont: =&gt; Unit): Int = {
        savedContinuation = Some(saveCont _)
        numberOfSavedContinuations = numberOfSavedContinuations + 1

        numberOfSavedContinuations
    }
}

def sub(m: M, x: X, subCont: Y =&gt; Unit):Int = {
    val y: Y = substuff(m, x)
    ContinuationSaver.save {subCont(y)}
}
</code></pre>

<p>并且我们也修改了调用链的其他方法以便把这个值返回出去。由于对<code>sub</code>的调用是<code>main</code>方法的最后一条语句，我们只需要修改<code>main</code>的返回值类型使之和<code>sub</code>的返回值类型一致即可。同样地，对<code>main</code>的调用是<code>prog</code>方法的最后一条语句，只需习惯<code>prog</code>的返回值类型使之和<code>main</code>的返回值类型一致即可。</p>

<pre><code>def prog(m: M):Int = {
    main(m, { (z: Z) =&gt; 
        println(z)
    })
}

def main(m: M, mainCont: Z =&gt; Unit):Int =&gt; {
    val x: X = pre(m)
    sub(m, x, 
    { (y: Y) =&gt; 
        {
            val z: Z = post(m, x, y)
            mainCont(z)
        }
    })
}
</code></pre>

<p>如果我们想的话，我们可以在<code>main</code>中修改从<code>sub</code>中返回的值做为<code>main</code>自己的返回值，甚至我们可以从<code>main</code>中返回一个与<code>sub</code>的返回值没有任何关系的值。</p>

<p>我们来回顾一下上面转换后的CPS代码。我们可以发现，未转换的代码拥有原始的返回值类型，转换后的CPS代码有转换后（可能完全不同）的返回值。</p>

<h4>Reset and Shift</h4>

<p>终于，我们有了足够的背景知识来理解Scala的 <code>reset</code> 和 <code>shift</code>关键字。</p>

<p>Scala中的delimited continuation是由EPFL的Tiark Rompf创建的。在他和Ingo Maier以及Martin Odersky合作的论文<a href="http://lamp.epfl.ch/~rompf/continuations-icfp09.pdf">Delimited Continuations in Scala</a>有详细描述。下面的资源部分也有Tiark的关于Delimited Continuations的博客。</p>

<p><code>reset</code>被用于标识delimited contiuation上界，只有<code>reset</code>内部代码才是CPS代码，<code>reset</code>的返回值不是CPS代码。</p>

<p><code>shift</code>被用于标识delimited continuation的下界，<code>shift</code>内部的代码不是CPS代码，(but it's untransformed return value is CPS)但是它的未转换的返回值是CPS。当<code>shift</code>执行时，会被传入一个传入一个从它的调用者开始到一个闭合的<code>reset</code>的continuation做为参数。</p>

<p>所以，<code>reset</code>和<code>shift</code>是从Direct Style到CPS，从CPS带Direct Style的转换器。所有在<code>reset</code>和<code>shift</code>之间的代码都是CPS。所有包含了<code>shift</code>的方法需要被标识为CPS，所有调用CPS方法的方法也需要被标识为CPS，直到遇到一个闭合的<code>reset</code>。</p>

<p>当你使用<code>reset</code>和<code>shift</code>时，continuation编译器插件就是对你的代码做类似我们上面的例子里的CPS转换操作。从<code>shift</code>块结束处开始到方法结束或者reset块结束的代码会被打包成一个closure，做为一个continuation传递给<code>shift</code>块。</p>

<p>我们来仔细研究下Scala中<code>reset</code>和<code>shift</code>的例子。</p>

<pre><code>reset {
    shift{ k: (Int =&gt; Int) =&gt;  k(7) } + 1
}
</code></pre>

<p><code>shift</code>语句告诉编译器插件重组代码，通过把从<code>shift</code>调用之后的代码转换成一个continuation，并且把这个continuation做为参数传递给<code>shift</code>语句。为了让这个例子更好懂一点，我们来做一下这个转换。</p>

<p>首先，我们把<code>shift</code>调用的结果赋值给一个变量，并且使用这个变量。</p>

<pre><code>reset {
    var r = shift{k: (Int =&gt; Int) =&gt; k(7)}
    r + 1
}
</code></pre>

<p>接下来，我们把<code>shift</code>块之后的代码转换成一个函数，并且调用之。</p>

<pre><code>reset {
    var r = shift{k: (Int =&gt; Int) =&gt; k(7)}

    def f(x: Int) =&gt; x + 1
    f(r)
}
</code></pre>

<p>这个函数<code>f</code>就是我们的continuation，它包含了从<code>shift</code>块结束到<code>reset</code>块结束的所有代码。</p>

<p>最后我们就像编译器插件那样，把我们的continuation函数f绑定到<code>shift</code>的参数<code>k</code>上。把转换后的代码的返回值做为<code>shfit</code>块的返回值。</p>

<pre><code>reset{
    def f(x: Int) = x + 1
    f(7)
}
</code></pre>

<p>现在我们可以直接看到，返回值是8。</p>

<p>我们也可以把同样的转换方式应用到</p>

<pre><code>reset {
    shift { k: (Int=&gt;Int) =&gt; k(k(k(7)))} + 1
}
</code></pre>

<p>会得到</p>

<pre><code>reset {
  def f(x:Int) = x + 1
  f(f(f(7)))
}
</code></pre>

<p>我们可以很容易地看出结果是10。</p>

<p>我们所有的转换都对<code>reset</code>外部的代码没有影响，例如</p>

<pre><code>reset {
  shift { k: (Int=&gt;Int) =&gt; k(7) } + 1
} * 2
</code></pre>

<p>给reset表达式的返回值乘以2，结果会是16。</p>

<p>Tiark的论文中展示了一个有趣的例子：</p>

<pre><code>reset {
  shift { k: (Int=&gt;Int) =&gt; k(k(k(7))); "done" } + 1
}
</code></pre>

<p>并指出这个代码的返回值是“done”。continuation函数被调用了三次，但是其返回值被抛弃了。对这段代码应用我们的代码转换过程，我们会得到下面的结果：</p>

<pre><code>reset {
  def f(x:Int) = x + 1
  f(f(f(7))); "done"
}
</code></pre>

<p>从这个代码中很容易看出来为什么返回是“done”。</p>

<p>值得注意的一点是，<code>reset</code>块的运算结果<strong>不像</strong>大多数代码那样，是这个块的最后一行。实际上，<code>reset</code>块的运算结果是它内部的<code>shift</code>块的最后一行。执行<code>shift</code>块永远是<code>reset</code>块内部最后做的一件事。</p>

<p>当你看到一个<code>shift</code>块，并且它的返回值被应用在一个表达式中时，比如上面的那个“shift + 1”的例子，请记住一点，由于代码的转换，这个从<code>shift</code>块中“return”从来没有真正地<strong>return</strong>过。实际上，当执行到<code>shift</code>块时，<code>shfit</code>块之后的代码被转换成一个continuation并做为参数传递给这个<code>shift</code>块；如果<code>shift</code>块中的代码执行了这个continuation，这个continuation的执行结果就表现为<code>shfit</code>块的返回值。<em>the value which is passed as an argument to the continuation appears as the value being returned from the shift block.</em>因此，传递给<code>shift</code>块中continuation 函数的参数的类型和代码中<code>shfit</code>块的返回值类型是一致的。 continuation 函数的返回值类型和这个<code>shift</code>块外围的<code>reset</code>块的返回值类型是一致的<em>Thus the type of the argument passed to the shift block's continuation function is the same as the type of the return value of the shift in the source code, and the type of the return value of that continuation function is the same as the type of the return value of the original last value in the reset block that encloses the shift block.</em></p>

<p>这里有三种类型与<code>shift</code>相关连：</p>

<ul>
<li>传递给continuation函数的参数类型，和shfit块的语义返回值类型一致。</li>
<li><p><em>The type of the argument to pass to the continuation, which is the same as the syntactic return type of the shift in the source code.</em></p></li>
<li><p>continuation函数的返回值类型，与从<code>shfit</code>块结束开始的代码的返回值类型一致。（例如，从<code>shift</code>块结束到函数结束或者<code>reset</code>块结束之间的代码的返回值类型）这被叫做<code>untransformaed return type</code>。</p></li>
<li><p><em>The type of the return from the continuation, which is the same as the return type of all of the code that follows the
shift block in the source code (i.e. the type of the last value in the block of code between the shift block and the end of the function or reset block containing the shift block). This is called the untransformed return type.</em></p></li>
<li><p><code>shift</code>块中最后一条语句的值，被做为整个函数或者<code>reset</code>块的返回值的类型。这个被称为<code>transformed return type</code></p></li>
<li>The type of the last value in the shift block, which becomes the type of the return value of the enclosing function or return block. This is called the transformed return type.</li>
</ul>


<p>在<code>shift</code>的方法签名中，上面的三个类型标记为<code>A</code>,<code>B</code>,<code>C</code>：</p>

<pre><code>def shift[A, B, C](func: ((A =&gt; B) =&gt; C)): A @scala.util.continuations.cpsParam[B, C]
</code></pre>

<p><code>cpsParam</code>注解中两个类型为未转换的返回值和已转换的返回值。关于注解<code>cpsParam</code>在<a id="cps-anotation">下面</a>有更详细的描述。</p>

<p><code>reset</code>的方法签名包含了两个类型：第一个类型是传给<code>reset</code>的代码块的未转换类型，和<code>shift</code>的<code>B</code>类型匹配；第二个类型是该代码块的已转换类型，和<code>shfit</code>的<code>C</code>类型匹配。同时也是<code>reset</code>块的真正返回类型。<code>reset</code>的scaladoc中用<code>A</code>和<code>C</code>来表示这两种类型，但是这里我使用<code>B</code>和<code>C</code>，因此这个<code>ctx</code>参数类型和<code>shift</code>的返回类型一致。</p>

<pre><code>def reset[B, C](ctx: =&gt; B @scala.util.continuations.cpsParam[B, C]): C
</code></pre>

<p>下面展示了这些类型都是在哪儿出现的：</p>

<pre><code>C = reset{…; A = shift{k: A =&gt; B =&gt; …; C}…;B}
</code></pre>

<p>在下面这个例子里，<code>A=Int, B =String, C=Boolean</code>:</p>

<pre><code>def is123(n: Int): Boolean = {
    reset{
        shift{k: (Int =&gt; String) =&gt;
         (k(n) == "123")
        }.toString
    }
}
</code></pre>

<h4>注解(WIP)</h4>

<h4>嵌套shift(WIP)</h4>

<h4>控制结构的限制(WIP)</h4>

<h4>建议(WIP)</h4>

<h4>资源(WIP)</h4>

    </div>
  </div>
</div>

<div id="disqus_thread" style="width:100%">
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'nicholasrensblog'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>

  </body>
</html>
