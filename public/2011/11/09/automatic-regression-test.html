<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <title>nicholasren.github.io by nicholasren</title>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26893631-1']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();

     </script>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>nicholasren.github.io</h1>
        <h2>ruby, scala </h2>
      </div>
    </header>

    <div class="container">
    <div class="content">
  <div class="row">
    <div class="span16">
      <div class="page-header">
        <h1>自动化回归测试</h1>
      </div>
      <p>注：本文假设你对<a href="http://cukes.info/" title="cucumber">Cucumber</a>，<a href="http://seleniumhq.org/projects/webdriver/" title="selenium">Selenium-WebDriver</a>有一定的了解。</p>

<h4>什么是回归测试？</h4>

<p>回归测试（regression test）是QA对程序功能问题的验证，通常我们的做法是: <br/>
QA 手工测试 -> 报告bug -> Dev 修bug -> 提交到代码库 -> 构建程序包 -> 部署-> QA手工测试 -> 报告bug, 如此反复...</p>

<p>试想随着版本需求范围的增加，回归测试的测试用例也会如滚雪球般越积越多，在实施回归测试的过程中，因此，手工测试对于QA来说是重复的、乏味的。</p>

<p>让我们来看一下回归测试的定义：</p>

<blockquote><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。 <br/>
回归测试的目的是，通过了回归测试的软件，至少其基本功能是可用的。</p></blockquote>

<h4>回归测试应该覆盖哪些内容？</h4>

<p>从上面的定义，我们就可以识别出哪些测试用例需要被包括到回归测试中： <br/>
   1. 与外部件集成的功能。 <br/>
   2. 主干功能。 <br/>
   3. 容易被break的测试。</p>

<h4>自动化回归测试</h4>

<p>既然测试范围已经确定了，接下来就要考虑如何减少这些重复的工作。我们很自然地想到了自动化。随之而来的问题是: <br/>
   1. 我们如何实施自动化？ <br/>
   2. 我们的项目时间很紧，如何在不影响项目进度的前提下实现自动化的回归测试？ <br/>
   3. 对于web项目，如何保证其在各个浏览器下面都能够正常工作？</p>

<p>对于第一、三个问题，有个成熟的方案，selenium-webdriver，其支持多种语言API, 包括Java,C#,Python,Perl,PHP,Ruby。也支持对多种浏览器的调用，可以模拟多种浏览器下对app的访问，并且支持对结果页面进行检查。
对于第二个问题，在经历过几次不是很成功的实践之后，我个人很反对对项目采用"休克疗法"，即完全停止目前的工作，采用另外一种看起来更好的方式来解决当前的问题，最具代表性的例子就是"打着重构的幌子进行重写"，在所谓的"重构"完成之前，项目其他成员的工作都是被阻塞住的，而且一旦"重构"失败，也难以恢复到"重构"前的状态。</p>

<p>在这里，我推荐一种循序渐进的方式逐步实现回归测试的自动化。 <br/>
举个例子：
在确定了回归测试的范围后，我需要测试一个网上书店的从最新书籍列表进入书籍详情页面的功能，我们分别用普通的测试用例和DSL描述的用例：</p>

<p><strong>普通的测试用例：</strong> <br/>
<em>预置条件</em>： <br/>
数据库中有三本书，其信息如下：</p>

<div class="highlight"><pre><code class="cucumber"><span class="nf">          ISBN          书名                       作者            价格 </span>
<span class="nf">         </span><span class="s">111111</span><span class="nf">    Head First Design Pattern      Somebody         </span><span class="s">12</span><span class="nf"></span>
<span class="nf">         </span><span class="s">222222</span><span class="nf">    Test Driven Development       Kent Beck         </span><span class="s">22</span><span class="nf"></span>
<span class="nf">         </span><span class="s">333333</span><span class="nf">         Refactor                 Martin Fowler     </span><span class="s">20</span><span class="nf"></span>
</code></pre></div>


<p><em>操作步骤：</em> <br/>
   进入书籍列表页面，点击书籍"Head First Design Pattern"的链接 <br/>
<em>预期结果：</em> <br/>
   进入书籍《Head First Design Pattern》详情页面，能够正确展示书籍名，价格，作者</p>

<p><strong>使用Cucumber DSL描述的测试用例：</strong></p>

<div class="highlight"><pre><code class="cucumber"><span class="nf">    </span><span class="k">Given </span><span class="nf">There are books as follows : </span>
<span class="k">        |</span><span class="s"> ISBN</span><span class="k">   |</span><span class="s"> 书名</span><span class="k">                      |</span><span class="s"> 作者</span><span class="k">          |</span><span class="s"> 价格</span><span class="k"> |</span><span class="nf"></span>
<span class="k">        |</span><span class="s"> 111111</span><span class="k"> |</span><span class="s"> Head First Design Pattern</span><span class="k"> |</span><span class="s"> Somebody</span><span class="k">      |</span><span class="s"> 12</span><span class="k">   |</span><span class="nf"></span>
<span class="k">        |</span><span class="s"> 222222</span><span class="k"> |</span><span class="s"> Test Driven Development</span><span class="k">   |</span><span class="s"> Kent Beck</span><span class="k">     |</span><span class="s"> 22</span><span class="k">   |</span><span class="nf"></span>
<span class="k">        |</span><span class="s"> 333333</span><span class="k"> |</span><span class="s"> Refactor</span><span class="k">                  |</span><span class="s"> Martin Fowler</span><span class="k"> |</span><span class="s"> 20</span><span class="k">   |</span><span class="nf"></span>
<span class="nf">     </span><span class="k">And </span><span class="nf">I am on the book list page</span>
<span class="nf">     </span><span class="k">And </span><span class="nf">I follow &quot;</span><span class="s">Head First Design Pattern</span><span class="nf">&quot;</span>
<span class="nf">     </span><span class="k">Then </span><span class="nf">I should be on book detail page</span>
<span class="nf">     </span><span class="k">And </span><span class="nf">I should see &quot;</span><span class="s">Head First Design Pattern</span><span class="nf">&quot; as title</span>
<span class="nf">     </span><span class="k">And </span><span class="nf">I should see &quot;</span><span class="s">12</span><span class="nf">&quot; as price</span>
<span class="nf">     </span><span class="k">And </span><span class="nf">I should see &quot;</span><span class="s">somebody</span><span class="nf">&quot; as author</span><span class="nv">&lt;/span&gt;</span><span class="nf"></span>
</code></pre></div>


<h4>渐进式实现自动化回归测试</h4>

<p>比较这两种形式的测试用例，我们排除语言实现的差异（中文和英文，而且Cucumber也是支持中文DSL的）， 它们的共同点是，都是人类可以理解的语言，任何一个QA都能够编写上述两种形式的测试用例。不同点在于，使用Cucumber DSL描述的测试用例可以在以后的某个时间点很容易地转换成自动化测试用例.</p>

<p>于是，我们可以在项目中采取如下形式逐步把回归测试自动化： <br/>
阶段一：</p>

<pre><code> 确定回归测试覆盖功能点的范围，
 使用cucumber DSL描述测试用例
 手工执行这些用例
</code></pre>

<p>阶段二：</p>

<pre><code> 利用项目间歇期，把这些使用cucumber DSL描述的测试用例转换成自动化测试。
 此时，项目中回归测试会存在自动化和手工测试两种形式，部分地节省了人力。
</code></pre>

<p>阶段三 :</p>

<pre><code> 所有的回归测试用例都被实现为自动化测试。
 这些测试都是可重复的，可以大大节省QA手工执行测试用例的时间。
 后期对回归测试用例的修改都相应地将其自动化。
</code></pre>

<p>就像重构一样，你可以在上面这三个阶段中的任何一个时刻停止，你也可以在停止之后继续。
如果你能够在你的项目里实践到阶段三，那么恭喜你，你们已经做到了让合适的人做合适的事情了。</p>

    </div>
  </div>
</div>

<div id="disqus_thread" style="width:100%">
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'nicholasrensblog'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>

  </body>
</html>
