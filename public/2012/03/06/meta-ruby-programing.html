<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <title>nicholasren.github.io by nicholasren</title>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26893631-1']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();

     </script>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>nicholasren.github.io</h1>
        <h2>ruby, scala </h2>
      </div>
    </header>

    <div class="container">
    <div class="content">
  <div class="row">
    <div class="span16">
      <div class="page-header">
        <h1>meta programing ruby读书笔记</h1>
      </div>
      <h2>Open Class</h2>

<p>  给予了你为class增加方法的能力，但是也如同打开了潘多拉魔盒，一旦通过Open Class增加了class方法导致重名问题，将很难定位。</p>

<h2>Instance variable</h2>

<p>  和Java不同，Ruby中的instance_variable 与class之间没有直接联系，你可以从一个class创建不同实例，并且各自拥有不同的instance variable.  (What's the purpose?)</p>

<h2>Method</h2>

<p>  Ruby中，method保存在class中</p>

<h2>Object</h2>

<p>  一个object是一组instance variable以及这个object所属的class的引用.</p>

<h2>Class</h2>

<p>  Ruby中，所有的class都是类Class的instance object.
  class是一个Class的实例、一组instance method、一个到super class的引用.</p>

<h2>Differences between Class and Module</h2>

<p>  Module is meant to be included (or mixined).
  Module can be used as namespace.
  Class is meant to be initlized or inherinted.</p>

<h2>Dynamic Methods</h2>

<p>  ruby中，可以在class定义时通过define_methods动态地定义方法,
如下代码动态地为class Computer添加了三个方法 mouse, cpu, keyboard:</p>

<pre><code>class Computer
    def initialize(computer_id, data_source)
      @id = computer_id
      @data_source = data_source
    end

  def self.define_component(name) 
    define_method(name) {
        info = @data_source.send "get_#{name}_info", @id
        price = @data_source.send "get_#{name}_price", @id 
      "#{name.to_s.capitalize}: #{info} ($#{price})" 
    }
  end

  define_component :mouse
  define_component :cpu
  define_component :keyboard
end
</code></pre>

<h2>Method Missing</h2>

<p>  ruby中，当尝试对receiver调用一个不存在的方法时，该receiver的method_missing方法会被调用，利用这一特性，可以通过重载 method_missing实现动态定义属性、方法效果, 通过method missing机制定义出来的方法被称为<em>Ghost Method</em>。
  例如：</p>

<pre><code>class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end

  def method_missing(name, *args)
    info = @data_source.send("get_#{name}_info", args[0])
    price = @data_source.send("get_#{name}_price", args[0])
    "#{name.to_s.capitalize}: #{info} ($#{price})"
  end

  #重写respond_to会使利用method_missing实现的动态方法与实际定义的方法无异
  def respond_to?(method)
    @data_source.respond_to?("get_#{method}_info") || super
  end
end
</code></pre>

<p>这些通过method_missing机制创建出来的methods被称为<code>ghost method</code>.</p>

<h2>Flat Scope</h2>

<p>在<em>ruby</em>中，<em>class</em>，<em>module</em>，def被称为scope gate，当程序遇到这几个关键字时，程序的scope就会发生变化，如果需要在scope之间共享变量，则可以使用<code>Class.new</code>代替<em>class</em>和<em>module</em>,
<code>Module#define_method</code>代替<em>def</em>，如：</p>

<pre><code>my_var = 12
MyClass = Class.new do
  # my_var is visiable here
  ...
  define_method :my_method do
    # my_var is visiable here
  end
end
</code></pre>

<h2>Object#instance_eval()</h2>

<p>  改变self的值为指定实例，同时改变“current class”为当前实例的eigenclass, 在此实例上下文中执行一个block</p>

<h2>Module#class_eval() or Module#module_eval()</h2>

<p>  改变self的值为指定实例，同时改变“current class”为当前方法的receiver，在此实例上下文中执行一个block</p>

<h2>Deferred Evaluation</h2>

<p>  定义一个block，proc，lambda，然后在其他地方调用此block，proc，lambda，这就叫做Deferred Evaluation</p>

<h2>Singleton Method</h2>

<p>  单独给一个object instance定义的method，称之为singleton method</p>

<p>  class methods可以认为是一个class对象的singleton method</p>

<h2>Class Macro</h2>

<p>  class macro看起来像是关键字，但是实际上就是普通的方法，但是这些方法常在声明定义class中使用。</p>

<h2>Eignclass</h2>

<p>  对象除了有一个其被创建时声明的那个class外，还会有它自己的一个不可见的，特殊的class，这个class被叫做eigenclass，也被称为singleton class。一个对象的singleton method就存在于这个对象的eignclass上，eignclass的superclass是这个对象的对外呈现的那个class(参考下面的示例代码)。</p>

<pre><code>class Duck
    #code omited
end
#Duck就是a_duck对外呈现的class
a_duck = Duck.new
</code></pre>

<p>通过下面的语法，你可以进入到一个对象的eignclass内部</p>

<pre><code>class &lt;&lt; obj
  # you are in the eigen class scope.
end
</code></pre>

<p>或者可以通过下面的语法获取对eignclass的引用</p>

<pre><code>metaclass = class &lt;&lt; matz; self; end
</code></pre>

<h3>Scope changing</h3>

<pre><code>class Person
  #self is the class object `Person` 
  class &lt;&lt; self
    #self is the eignclass of class object `Person`
    def species
      "Homo Sapien"
    end
  end
end

Person.instance_eval do
  #method will be defined on eignclass  of class object `Person`
  #but self is the class object `Person`
  def species
    "Homo Sapien"
  end

  self.name #=&gt; "Person"
end
</code></pre>

<h3>给对象的eignclass增加singleton方法：</h3>

<pre><code>#给对象增加singleton方法
matz = Object.new
def matz.speak
  "Place your burden to machine's shoulders"
end

#给类增加singleton方法（class methods）
class Person
end

def Person.speak 
  "Place your burden to machine's shoulders"
end
</code></pre>

<h2>Class Extension Mixin</h2>

<pre><code>module M
  def included(clazz)
    clazz.extend ClassMethods
  end

  #定义在这个内部module里的方法会变成inclusor的class method
  module ClassMethods
    def a_class_method
    end
  end
end
</code></pre>

    </div>
  </div>
</div>

<div id="disqus_thread" style="width:100%">
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'nicholasrensblog'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </div>

  </body>
</html>
